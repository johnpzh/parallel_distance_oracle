**Updates:**

- 12/14/2018: 
	1. Add a new table named label table `labels_table`. It records labels of every vertex. The previous `dist_table` is then used only for recording shortest distances.
	2. When checking candidates of every vertex, the candidate distance table `cand_dist_table` is also used.
	3. Add two options to filter out those wrong or redundant distances in the label table `labels_table`. One option is to do filtering out when any vertex notices the wrong distance; another option is to do it after the whole label table is finished.

# From a Vertex View

Every root `r` has an array recording the shortest distance so far to every vertex (`dist_table[r]`). Meanwhile, every vertex `v` also has an array recording the temporary labels (`labels_table[v]`). If `labels_table[v][r] != INF`, it means a label `(r, labels_table[v][r])` should be added into `v`'s label `L[v]`. For now, all vertices are roots because we make them active all together at the beginning. So the length of those arrays are all `N`.

An iteration has two stages. In the first stage, vertex `v` receives distances from all its neighbors. A neighbor contains up to `N` distances to every root and sends them all to vertex `v`. For every distance of a higher ranked root, vertex `v` will check if it should record this distance in its temporary distance array (`cand_dist_table[v]`). For example, assume vertex `v` receives from its neighbor `w` the distance between `w` and root `r` as `dist_r_w` and `rank(r) > rank(v)`. At first, vertex `v` adds this distance and the edge weight of `(w, v)`, so it gets `tmp_dist_r_v = dist_r_w + weight(w, v)`. Then vertex `v` will check if `tmp_dist_r_v < dist_table[r][v] AND tmp_dist_r_v < cand_dist_table[v][r]`.  If so, vertex `v` will mark root `r` as one of its candidate. To the end, vertex `v` updates the temporary shortest distance `cand_dist_table[v][r] = tmp_dist_r_v`. Additionally, vertex `v` updates the shortest distance `dist_table[r][v] = tmp_dist_r_v`. From every neighbor, vertex `v` will receive up to `N` distances. After vertex `v` receives all those distances, its `cand_dist_table[v]` records the temporary shortest distances to all roots.

In the second stage, a vertex needs to check if it needs to update its shortest distances from roots according to its temporary distances. For a temporary distance between a candidate and a vertex, the vertex needs to check if the distance could already be obtained by going through other roots. For example, for vertex `v` and its candidate `c`, they have `tmp_dist_v_c = cand_dist_table[v][c]`. For every other root `r` with `rank(r) > rank(c)`, vertex `v` needs to check if the distance from `c` to `r` plus `r` to `v` can already cover the temporary distance. That is to check if `labels_table[r][c] + labels_table[r][v] <= tmp_dist_v_c OR cand_dist_table[c][r] + cand_dist_table[v][r] <= tmp_dist_v_c`. If *not*, it means vertex `v` receives a new shortest distance to `c`, so it will add a new distance of label as `labels_table[v][c] = tmp_dist_v_c`. Vertex `v` needs to do the check for all its candidates and try to update its shortest distances. If any shortest distance was updated successfully, vertex `v` would be marked as a new active vertex.

In the next iteration, those new active vertices will sends their distances to their neighbors. Iterations will continue until no active vertices anymore. In the end, `labels_table` has all information for building the index. For a vertex `v`, for every root `r` which has `labels_table[r][v] != INF`, a label `(r, dist_table[r][v])` needs to be inserted into `v`' label `L[v]`.

However, `labels_table` might contain some wrong distances which are actually larger than the supposed shortest distance. Those wrong distances are added into the table before the real shortest distance is found. Although those wrong distances do not influence the distance query results, they increase the size of the final index. Here we have two options to filter out those wrong distances from `labels_table`. 

The first is at the point of checking candidates' distances. If a vertex `v` noticed that its candidate `c` already had a shorter distance which could be recovered by other path, it means a wrong or redundant distance to `c` must already be added into one of `v`'s neighbor's distance array and label array, and then the neighbor sent the wrong distance of `c` to `v`. In order to correct the wrong distance, when vertex `v` notices the wrong distance to `c`, it starts sending the new shortest distance of `c` to its neighbors in order to correct those potential mistakes in their arrays. Assume one of `v`'s neighbors `w` receives the distance between `c` and `v` as `dist_c_v` and `rank(c) > rank(w)`. At first, `w` will add it with edge weight `(v, w)`, so it gets `tmp_dist_c_w = dist_c_v + weight(v, w)`. Then it checks if `tmp_dist_c_w <= dist_table[c][w]`. If so, it means `w` had a wrong or redundant distance to `c`. Therefore, `w` changes `dist_table[c][w] = tmp_dist_c_w`, and also reset `labels_table[w][c] = INF` as the distance will be covered by other labels. In the next iteration, `w` will send its `dist_table[c][w]` to its neighbors. The correcting process will continue until no updates in `dist_table` or `labels_table` anymore.

The second option is to do the correcting at the ending point when the whole `label_table` is finished. For every vertex `v`, it is to check its every non-`INF` element in `label_table[v]` to see if it can be covered by `v`'s higher-ranked labels. For example, if `label_table[v][r] != INF`, it needs to check all label `hop_i` with `rank(hop_i) > rank(r)` to see if `dist_table[hop_i][v] + dist_table[hop_i][r] <= label_table[v][r]`. If so, it corrects `label_table[v][r] = INF`. The process will end when all vertices have finished checking.

# From a Graph View
All vertices are active at first. They send their distances to their neighbors. Every distance is from a root to the vertex. The neighbor will receive the distance and plus it with the edge weight and record the sum as a temporary distance to the corresponding root. After all active vertices finish sending, vertices begins to check all its received distances. The distance should not be covered by through other roots, then the vertex update the distance as one of its shortest distance to a root. After all vertices finish checking, those vertices with updated shortest distances are marked as new active vertices. They begins to send distances in the next iteration. The iterations continue until no more active vertices.

