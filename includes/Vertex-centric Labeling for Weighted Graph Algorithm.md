# From a Vertex View

Every root `r` has an array recording the shortest distance so far to every vertex (`dist_table[r]`). Meanwhile, every vertex `v` also an array recording the temporary shortest distance received from its neighbors (`cand_dist_table[v]`). For now, all vertices are roots because we make them active all together at the beginning. So every vertex has two distance arrays with length `N`.

An iteration has two stages. In the first stage, vertex `v` receives distances from all its neighbors. A neighbor contains up to `N` distances to every root. For every distance of a higher ranked root, vertex `v` will check to see if it should record this distance in its temporary distance array. For example, assume vertex `v` receives from its neighbor `w` the distance between `w` and root `r` as `dist_r_w` and `rank(r) > rank(v)`. Vertex `v` adds this distance plus the edge weight of `(w, v)`, so it gets `tmp_dist = dist_r_w + weight(w, v)`. Then vertex `v` will check if `tmp_dist < dist_table[r][v] AND tmp_dist < cand_dist_table[v][r]`.  If so, vertex `v` will mark root `r` as one of its candidate. To the end, vertex `v` updates the temporary shortest distance `cand_dist_table[v][r] = tmp_dist`. From every neighbor, vertex `v` will receive up to `N` distances. After vertex `v` receives all those distances, its `cand_dist_table[v]` records the temporary shortest distance to all roots.

In the second stage, a vertex needs to check if it needs to update its shortest distance to roots according to those temporary distances. For a temporary distance from a candidate to a vertex, the vertex needs to check if the distance could already be obtained by passing other roots. For example, for vertex `v` and its candidate `c`, they have `dist_v_c = cand_dist_table[v][c]`. For every other root `r`, vertex `v` needs to check if the distance from `c` to `r` plus `r` to `v` could already cover the temporary distance. That is to check if `dist_table[r][v] + dist_table[c][r] <= dist_v_c`. If not, it means vertex `v` receives a new shortest distance to `c`, so it will update its shortest distance as `dist_table[c][v] = dist_v_c`. Vertex `v` needs to do the check for all its candidates and try to update its shortest distances. If any shortest distance was updated successfully, vertex `v` would be marked as a new active vertex which would send its distances to all its neighbors.

The iterations will continue until no active vertices anymore. For a vertex `v`, for every root `r` which has `dist_table[r][v] != INF`, a label `(r, dist_table[r][v])` needs to be inserted into `v`' label `L[v]`.

# From a Graph View
All vertices are active at first. They their distances to its neighbors. Every distance is from a root to the vertex. The neighbor will receive the distance and plus it with the edge weight and record it as a temporary distance to the corresponding root. After all active vertices finish sending, vertices begins to check all its received distances. The distance should not be covered by through other roots, then the vertex update the distance as one of its shortest distance to a root. After all vertices finish checking, those vertices with updated shortest distances are new active verices. They begins to send distances in the next iteration. The iterations continue until no more active vertices.

